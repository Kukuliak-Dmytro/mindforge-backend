generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum UserRole {
  STUDENT
  TUTOR
}

model User {
  id             String            @id @default(uuid()) @db.Uuid
  email          String            @unique
  firstName      String
  lastName       String
  avatarUrl      String?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  role           UserRole          @default(STUDENT)
  
  // Better Auth required fields
  emailVerified  Boolean           @default(false)

  // Profile relations
  studentProfile StudentProfile?
  tutorProfile   TutorProfile?

  // Common relations
  sentMessages   Message[]
  
  // Better Auth relations
  authSessions   AuthSession[]
  accounts       Account[]
}

model StudentProfile {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @unique @db.Uuid
  bio       String?
  phone     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Student-specific relations
  studentOrders  Order[]           @relation("StudentOrders")
  studentReviews Review[]          @relation("StudentReviews")
  
  // Relations for invites and saving
  studentInvites OrderInvite[]      @relation("StudentInvites")
  savedTutors    SavedTutor[]       @relation("SavedTutorsStudent")
}

model TutorProfile {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @unique @db.Uuid
  bio       String?
  phone     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Tutor-specific relations
  tutorOrders    Order[]           @relation("TutorOrders")
  tutorReviews   Review[]          @relation("TutorReviews")
  education      TutorEducation[]
  experiences    TutorExperience[]
  subjects       TutorSubject[]
  
  // Relations for invites and saving
  tutorInvites   OrderInvite[]      @relation("TutorInvites")
  savedOrders    SavedOrder[]       @relation("SavedOrdersByTutor")
  savedTutors    SavedTutor[]       @relation("SavedTutorsTutor")
}

model TutorEducation {
  id             String    @id @default(uuid()) @db.Uuid
  tutorProfileId String    @db.Uuid
  institution    String
  fieldOfStudy   String
  degree         String
  startDate      DateTime
  endDate        DateTime?
  tutorProfile   TutorProfile @relation(fields: [tutorProfileId], references: [id], onDelete: Cascade)
}

model TutorExperience {
  id             String    @id @default(uuid()) @db.Uuid
  tutorProfileId String    @db.Uuid
  institution    String
  title           String
  startDate       DateTime
  endDate         DateTime?
  tutorProfile    TutorProfile @relation(fields: [tutorProfileId], references: [id], onDelete: Cascade)
}

model TutorSubject {
  id             String    @id @default(uuid()) @db.Uuid
  tutorProfileId String    @db.Uuid
  subjectId      String    @db.Uuid
  categoryId     String    @db.Uuid
  price          Decimal

  // Relations
  tutorProfile   TutorProfile @relation(fields: [tutorProfileId], references: [id], onDelete: Cascade)
  subject        Subject      @relation(fields: [subjectId], references: [id])
  category       Category     @relation(fields: [categoryId], references: [id])

  @@unique([tutorProfileId, subjectId, categoryId])
}

model Subject {
  id            String         @id @default(uuid()) @db.Uuid
  name          String         @unique
  tutorSubjects TutorSubject[]
  orders        Order[]
}

model Category {
  id            String         @id @default(uuid()) @db.Uuid
  name          String         @unique
  isRecurring   Boolean        @default(false)
  tutorSubjects TutorSubject[]
  orders        Order[]
}

model Order {
  id                String    @id @default(uuid()) @db.Uuid
  studentProfileId  String    @db.Uuid
  tutorProfileId   String?   @db.Uuid
  subjectId         String    @db.Uuid
  categoryId        String    @db.Uuid
  title             String
  description       String?
  createdAt         DateTime  @default(now())
  status            String
  totalPrice        Decimal
  sessionsCount     Int
  sessionsCompleted Int       @default(0)
  chat              Chat?
  
  // Relations
  category          Category      @relation(fields: [categoryId], references: [id])
  studentProfile    StudentProfile @relation("StudentOrders", fields: [studentProfileId], references: [id])
  subject           Subject       @relation(fields: [subjectId], references: [id])
  tutorProfile      TutorProfile? @relation("TutorOrders", fields: [tutorProfileId], references: [id])
  reviews           Review[]
  sessions          Session[]

  // Relations for invites
  invites           OrderInvite[]

  // Relations for saving
  savedByTutors SavedOrder[] @relation("SavedOrdersByOrder")
}

model Session {
  id             String    @id @default(uuid()) @db.Uuid
  orderId        String    @db.Uuid
  scheduledStart DateTime
  scheduledEnd   DateTime
  actualStart    DateTime?
  actualEnd      DateTime?
  status         String
  meetingLink    String?
  order          Order     @relation(fields: [orderId], references: [id])
}

model Review {
  id              String    @id @default(uuid()) @db.Uuid
  orderId         String    @db.Uuid
  studentProfileId String   @db.Uuid
  tutorProfileId  String    @db.Uuid
  rating          Int
  comment          String?
  createdAt       DateTime  @default(now())
  
  // Relations
  order           Order          @relation(fields: [orderId], references: [id])
  studentProfile  StudentProfile @relation("StudentReviews", fields: [studentProfileId], references: [id])
  tutorProfile    TutorProfile   @relation("TutorReviews", fields: [tutorProfileId], references: [id])
}

model Chat {
  id        String    @id @default(uuid()) @db.Uuid
  orderId   String    @unique @db.Uuid
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  
  // Relations
  order     Order     @relation(fields: [orderId], references: [id])
  messages  Message[]
}

model Message {
  id        String    @id @default(uuid()) @db.Uuid
  chatId    String    @db.Uuid
  senderId  String    @db.Uuid
  content   String
  createdAt DateTime  @default(now())
  isRead    Boolean   @default(false)
  
  // Relations
  chat      Chat      @relation(fields: [chatId], references: [id])
  sender    User      @relation(fields: [senderId], references: [id])
}

model OrderInvite {
  id             String    @id @default(uuid()) @db.Uuid
  orderId        String    @db.Uuid
  tutorProfileId String    @db.Uuid
  studentProfileId String  @db.Uuid
  senderRole     UserRole
  status         InviteStatus
  message        String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relations
  order          Order     @relation(fields: [orderId], references: [id])
  tutorProfile   TutorProfile @relation("TutorInvites", fields: [tutorProfileId], references: [id])
  studentProfile StudentProfile @relation("StudentInvites", fields: [studentProfileId], references: [id])
}

enum InviteStatus {
  PENDING
  ACCEPTED
  REFUSED
}

model SavedOrder {
  id             String   @id @default(uuid()) @db.Uuid
  tutorProfileId String   @db.Uuid
  orderId        String   @db.Uuid
  createdAt      DateTime @default(now())

  tutorProfile   TutorProfile @relation("SavedOrdersByTutor", fields: [tutorProfileId], references: [id])
  order          Order        @relation("SavedOrdersByOrder", fields: [orderId], references: [id])

  @@unique([tutorProfileId, orderId])
}

model SavedTutor {
  id               String   @id @default(uuid()) @db.Uuid
  studentProfileId String   @db.Uuid
  tutorProfileId   String   @db.Uuid
  createdAt        DateTime @default(now())

  studentProfile   StudentProfile @relation("SavedTutorsStudent", fields: [studentProfileId], references: [id])
  tutorProfile      TutorProfile  @relation("SavedTutorsTutor", fields: [tutorProfileId], references: [id])

  @@unique([studentProfileId, tutorProfileId])
}

// Better Auth Models
model AuthSession {
  id        String   @id @default(uuid()) @db.Uuid
  expiresAt DateTime @db.Timestamptz(6)
  token     String   @unique
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @db.Timestamptz(6)
  ipAddress String?
  userAgent String?
  userId    String   @db.Uuid

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Account {
  id                      String    @id @default(uuid()) @db.Uuid
  accountId               String
  providerId              String
  userId                  String    @db.Uuid
  accessToken             String?
  refreshToken            String?
  idToken                 String?
  accessTokenExpiresAt    DateTime? @db.Timestamptz(6)
  refreshTokenExpiresAt   DateTime? @db.Timestamptz(6)
  scope                   String?
  password                String?
  createdAt               DateTime  @default(now()) @db.Timestamptz(6)
  updatedAt               DateTime  @updatedAt @db.Timestamptz(6)

  user                    User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@index([userId])
}

model Verification {
  id         String   @id @default(uuid()) @db.Uuid
  identifier String
  value      String
  expiresAt  DateTime @db.Timestamptz(6)
  createdAt  DateTime @default(now()) @db.Timestamptz(6)
  updatedAt  DateTime @updatedAt @db.Timestamptz(6)

  @@index([identifier, value])
}
